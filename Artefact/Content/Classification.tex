\subsection{Classification Problem} \label{Sec: Classification Problem}
We implement a variational quantum classifier as previously discussed in the section \ref{VQA}.
The algorithm includes two stages: a training stage and a classification stage.
We use a dataset generated by the Qiskit machine learning package for the algorithm.
The data was also used for a classification algorithm by Havlíček et al. \cite{havlicekSupervisedLearningQuantumenhanced2019}.

The quantum circuit for both stages is constructed from three parts: the feature map to encode data, the ansatz to perform optimisation and finally, a final rotation layer for measurement (see Figure \ref{Fig: Quantum circuit for classifier}).
The number of features will dictate the number of qubits, in our case, we will be using two qubits for the quantum circuit.
For the methods unrestricted and layerwise learning, there is no restriction on ansatz depth, so we build the ansatz to have 7 repetitions (15 depth units).
For the method local cost function - shallow depth, we only use two repetitions (5 depth units).
For the identity blocks method, we construct the ansatz to have a depth closer to the unrestricted method. 
We will be using three identity blocks as the ansatz, which results in 18 depth units.

The dataset consisted of 50 labelled datapoints with two features used for the training process.
The Gradient Descent algorithm provided by Qiskit will estimate the quantum circuit to optimise the ansatz parameters in maximum of 300 iterations.
For the classification benchmark, we use another set of 20 datapoints, and run the classifier with the optimised parameters obtained from the training stage.
The classifier would produce the predicted labels for each testing datapoint.
Then, we compare these predicted labels to the actual provided labels.

We collect the optimiser' history (loss function per iteration) by implementing a callback function for Gradient Descent algorithm.
The score $s$ of the classifier is calculated as the percentage likeliness of the predicted labels array compared to the actual labels array:
\begin{equation}
    s = 100\% (1 - \text{MSE})
\end{equation}
for $\text{MSE}$ is the mean square error of the actual labels array $Z$ and predicted labels array $\hat{Z}$ of length $n$:
\begin{equation}
    \text{MSE} = \frac{1}{n}\sum^n_{i=1}(Z_i - \hat{Z}_i)^2,
\end{equation}



\begin{figure}
    \centerline{
    \Qcircuit @C=1em @R=2em {
    \lstick{\ket{0}} & \multigate{1}{U_{\phi}(\vec{x})}    & \multigate{1}{W(\vec{\theta})}    & \meter & \rstick{z_1} \cw \\
    \lstick{\ket{0}} & \ghost{U_{\phi}(\vec{x})}           & \ghost{W(\vec{\theta})}           & \meter & \rstick{z_n} \cw \\
    }
    }
    \caption{
        Quantum Variational Classifier implemented for the experiment.
        The initial qubit state $\ket{0}^n$ is applied with a feature map $U_{\phi}(\vec{x})$ to encode data $\vec{x}$ from our dataset.
        Then, a unitary operation $W(\vec{\theta})$ is applied as the ansatz, follow up with a measurement layer.
        The output string $z \in \{0,1\}^n$ is mapped as the label for the given datapoint $\vec{x}$.
    }
    \label{Fig: Quantum circuit for classifier}
\end{figure}
