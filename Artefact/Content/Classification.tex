\subsection{Classification Problem} \label{Sec: Classification Problem}
We implement a variational quantum classifier as previously discussed in the section \ref{VQA}.
The algorithm includes two stages: a training stage and a classification stage.
We use a dataset generated by Qiskit machine learning package for the algorithm.
The data was also used for a classification algorithm by Havlíček et al. \cite{havlicekSupervisedLearningQuantumenhanced2019}.

The quantum circuit for both stages is constructed from three parts: the feature map to encode data, the ansatz to perform optimisation and finally, a final rotation layer for measurement (see Figure \ref{Fig: Quantum circuit for classifier}).
The number of features will dictiate the number of qubits, in out case, we will be using two qubits for the quantum circuit.
For the method \#0 and \#2, there is no restriction on ansatz depth, so we build the ansatz to have 7 repetitions (15 depth units).
For the method \#1 with restriction for ansatz depth, we only use 2 reptitions (5 depth units).
For the customised ansatz in method \#3, we construct the ansatz to have the depth closer to that of method \#1 and \#2. We will be using three identity blocks as the ansatz, which results in 18 depth units.

The dataset consited of 50 labeled datapoints with two features is used for the traning stage.
The quantum circuit will be estimated as required by Gradient Descent algorithm provided by Qiskit to optimise the ansatz parameters.
For the classification satge, we use another set of 20 datapoints, and run the classifier with the optimised parameters obtained from the training stage.
The classifier would produce the predicted labels for each testing datapoint.
Then, we compare these predicted labels to the actual provided labels.

We collect the optimizer history (loss function per iteration) by implement a callback function for Gradient Descent algorithm.
The score $s$ of the classifier is calculate as the percentage likeliness of the predicted labels array compared to the actual labels array:
\begin{equation}
    s = 100\% (1 - \text{MSE})
\end{equation}
for $\text{MSE}$ is the mean square error of the actual labels array $Z$ and predicted labels array $\hat{Z}$ of length $n$:
\begin{equation}
    \text{MSE} = \frac{1}{n}\sum^n_{i=1}(Z_i - \hat{Z}_i)^2,
\end{equation}



\begin{figure}
    \centerline{
    \Qcircuit @C=1em @R=2em {
    \lstick{\ket{0}} & \multigate{1}{U_{\phi}(\vec{x})}    & \multigate{1}{W(\vec{\theta})}    & \meter & \rstick{z_1} \cw \\
    \lstick{\ket{0}} & \ghost{U_{\phi}(\vec{x})}           & \ghost{W(\vec{\theta})}           & \meter & \rstick{z_n} \cw \\
    }
    }
    \caption{
        Quantum Variational Classifier implemented for the experiment.
        The initial qubit state $\ket{0}^n$ is applied with a feature map $U_{\phi}(\vec{x})$ to encode data $\vec{x}$ from our dataset.
        Then, an unitary operation $W(\vec{\theta})$ is applied as the ansatz, follow up with a measurement layer.
        The output string $z \in \{0,1\}^n$ is mapped as label for the given datapoint $\vec{x}$.
    }
    \label{Fig: Quantum circuit for classifier}
\end{figure}
