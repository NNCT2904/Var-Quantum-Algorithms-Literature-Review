\subsection{Classification Problem} \label{Sec: Classification Problem}
We implement a variational quantum classifier as previously discussed in the section \ref{VQA}.
The algorithm includes two stages: a training stage and a classification stage.
We use a dataset which contain thirty features to identify the presence of breast cancer.
We apply Principal Component Analysis to the dataset obtain five training features.

The quantum circuit for is constructed from three parts: the feature map to encode data, the ansatz to perform optimisation and finally, a final rotation layer for measurement (see Figure \ref{Fig: Quantum circuit for classifier}).
The number of features will dictate the number of qubits, in our case, we will be using two qubits for the quantum circuit.
For the methods unrestricted and layerwise learning, there is no restriction on ansatz depth, so we build the ansatz to have 20 repetitions (165 depth units).
For the method local cost function - shallow depth, we only use three repetitions (25 depth units).
For the identity blocks method, we will be using ten identity blocks as the ansatz, which results in 200 depth units.

\todo{describe more about COBYLA and its characteristic}
The dataset consisted of 80 labelled datapoints with five features used for the training process.
The COBYLA algorithm provided by Qiskit will estimate the quantum circuit to optimise the ansatz parameters in maximum of 150 iterations.
The cost function value for COBYLA algorithm is calculated as squared error.
For the classification benchmark, we use another set of 20 datapoints, and run the classifier with the optimised parameters obtained from the training stage.
The classifier would produce the predicted labels for each testing datapoint.
Then, we compare these predicted labels to the actual provided labels.

We collect the optimiser' history (loss function per iteration) by implementing a callback function for the variational quantum classifier.
The accuracy score $s$ of the classifier is calculated as the percentage likeliness of the predicted labels array compared to the actual labels array:
\begin{equation}
    s = 100\% (1 - \text{MSE})
\end{equation}
for $\text{MSE}$ is the mean square error of the actual labels array $Z$ and predicted labels array $\hat{Z}$ of length $n$:
\begin{equation}
    \text{MSE} = \frac{1}{n}\sum^n_{i=1}(Z_i - \hat{Z}_i)^2,
\end{equation}



\begin{figure}
    \centerline{
    \Qcircuit @C=1em @R=0.7em {
    \lstick{\ket{0}} & \multigate{2}{U_{\phi}(\vec{x})}    & \multigate{2}{W(\vec{\theta})}     & \meter & \rstick{z_1}      \cw \\
    \lstick{\vdots}  & \ghost{U_{\phi}(\vec{x})}           & \ghost{W(\vec{\theta})}            & \meter & \rstick{\vdots}   \cw \\
    \lstick{\ket{0}} & \ghost{U_{\phi}(\vec{x})}           & \ghost{W(\vec{\theta})}            & \meter & \rstick{z_n}      \cw \\
    }
    }
    \caption{
        Quantum Variational Classifier implemented for the experiment.
        The initial qubit state $\ket{0}^n$ is applied with a feature map $U_{\phi}(\vec{x})$ to encode data $\vec{x}$ from our dataset.
        Then, a unitary operation $W(\vec{\theta})$ is applied as the ansatz, follow up with a measurement layer.
        The output string $z \in \{0,1\}^n$ is mapped as the label for the given datapoint $\vec{x}$.
    }
    \label{Fig: Quantum circuit for classifier}
\end{figure}
